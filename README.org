* Method
** Parallel for loop
- [[file:thread_pool.h][Custom multi-threading code]] to create parallel operations.
- Same number of threads launched, different number of jobs submitted

** Multi-threaded kernel functions
- [[file:kernels.cpp][Kernels]] run on any number of threads
- Each stress the CPU in slightly different ways

** Timing code
- [[file:time.py][Timing and plotting]] done with a quick python script.
- Varies number of threads from 1-8
- Plot speedup vs number of threads per kernel

* Benchmark results
** Results
*** [[file:add.cpp][Floating point addition]]
    [[./figs/add.png]]

*** [[file:div.cpp][Division bound task]]
    [[./figs/div.png]]

*** [[file:mem.cpp][Memory bound task]]
[[./figs/mem.png]]

** Why add is different
   [[./figs/skylake_scheduler.png]]

** Multiple kernel benchmarks
*** [[file:div_add.cpp][Division and addition]]
[[./figs/div_add.png]]

*** [[file:add_mem.cpp][Addition and memory]]
[[./figs/add_mem.png]]

*** [[file:div_mem.cpp][Division and memory]]
[[./figs/div_mem.png]]

** More complex kernels
*** [[file:nbody.cpp][N-body forces calculation]]
[[./figs/nbody.png]]

*** [[file:nbody_add.cpp][N-body and addition]]
    [[./figs/nbody_add.png]]

*** [[file:nbody_mem.cpp][N-body and memory]]
    [[./figs/nbody_mem.png]]

* Building and running IACA
** Building
- mkdir build && cd build
- cmake -DCMAKE_BUILD_TYPE=Release ..
- make

** Running intel architecture code analyser
- Uncomment IACA_BEGIN and IACA_END from the kernel code
- cmake --build build
- iaca/iaca -arch HSW build/libkernels.a
